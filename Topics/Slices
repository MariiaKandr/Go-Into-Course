Тип slice в Go предоставляет удобный и эффективный способ работы с последовательностями типизированных данных. Слайсы аналогичны массивам в других языках, но обладают некоторыми необычными свойствами. В этой статье мы рассмотрим, что такое слайсы и как они используются.

## Массивы

Тип slice — это абстракция, созданная на основе типа массива в Go. Чтобы понять, что такое срезы, нужно сначала разобраться с массивами.

Определение типа массива указывает на его длину и тип элементов. Например, тип [4]int представляет собой массив из четырёх целых чисел. Размер массива фиксирован; его длина является частью его типа ([4]int и [5]int — разные, несовместимые типы). Массивы можно индексировать обычным способом, поэтому выражение s[n] обращается к n-му элементу, начиная с нуля.

```go
var a [4]int
a[0] = 1
i := a[0]
// i == 1
````

Массивы не нужно инициализировать явно. Нулевое значение массива — это готовый к использованию массив, элементы которого сами по себе обнулены.

```
// a[2] == 0, the zero value of the int type
```
https://go.dev/blog/slices-intro/slice-array.png. 

В памяти [4]int представлен всего четырьмя целочисленными значениями, расположенными последовательно:

Массивы в Go — это значения. Переменная-массив обозначает весь массив; это не указатель на первый элемент массива (как в C). Это означает, что при присваивании или передаче значения массива будет создана копия его содержимого. (Чтобы избежать копирования, можно передать указатель на массив, но тогда это будет указатель на массив, а не сам массив.) Массивы можно рассматривать как своего рода структуры, но с индексированными, а не именованными полями: составное значение фиксированного размера.

Массивный литерал можно указать следующим образом:

```go
b := [2]string{"Penn", "Teller"}
```

Или вы можете попросить компилятор подсчитать количество элементов в массиве:

```go
b := [...]string{"Penn", "Teller"}
```

В обоих случаях тип b — [2]string.

## Слайсы

Массивы имеют свое место, но они немного негибкие, поэтому вы не слишком часто увидите их в коде Go. Однако фрагменты есть везде. Они основаны на массивах, обеспечивая большую мощность и удобство.

Спецификация типа для среза выглядит так: []T, где T — тип элементов среза. В отличие от типа массива, тип среза не имеет заданной длины.

Срез-литерал объявляется так же, как и массив-литерал, за исключением того, что не указывается количество элементов:

```go
letters := []string{"a", "b", "c", "d"}
```

Срез можно создать с помощью встроенной функции make, которая имеет следующий синтаксис:

```
func make([]T, len, cap) []T
```

где T обозначает тип элемента создаваемого среза. Функция make принимает тип, длину и необязательную ёмкость. При вызове make выделяет массив и возвращает срез, ссылающийся на этот массив.

```go
var s []byte
s = make([]byte, 5, 5)
// s == []byte{0, 0, 0, 0, 0}
```

Если аргумент capacity не указан, по умолчанию используется указанная длина. Вот более лаконичная версия того же кода:

```go
s := make([]byte, 5)
```

Длину и ёмкость среза можно проверить с помощью встроенных функций len и cap .

```
len(s) == 5
cap(s) == 5
```

В следующих двух разделах рассматривается взаимосвязь между длиной и вместимостью.

Нулевое значение среза — nil. Функции len и cap возвращают 0 для пустого среза.

Срез также можно создать, «нарезав» существующий срез или массив. Для этого нужно указать полуоткрытый диапазон с двумя индексами, разделёнными двоеточием. Например, выражение b[1:4] создаёт срез, включающий элементы с 1-го по 3-й в массиве b (индексы результирующего среза будут от 0 до 2).

```go
b := []byte{'g', 'o', 'l', 'a', 'n', 'g'}
// b[1:4] == []byte{'o', 'l', 'a'}, sharing the same storage as b
```

Начальный и конечный индексы выражения среза являются необязательными. По умолчанию они равны нулю и длине среза соответственно:

```
// b[:2] == []byte{'g', 'o'}
// b[2:] == []byte{'l', 'a', 'n', 'g'}
// b[:] == b
```

Это также синтаксис для создания среза на основе массива:

```go
x := [3]string{"Лайка", "Белка", "Стрелка"}
s := x[:] // a slice referencing the storage of x
```

## Внутреннее устройство¶

Срез — это дескриптор сегмента массива. Он состоит из указателя на массив, длины сегмента и его ёмкости (максимальной длины сегмента).

https://go.dev/blog/slices-intro/slice-struct.png

Наша переменная s, созданная ранее с помощью make([]byte, 5), имеет следующую структуру:

https://go.dev/blog/slices-intro/slice-1.png

Длина — это количество элементов, на которые ссылается срез. Ёмкость — это количество элементов в базовом массиве (начиная с элемента, на который ссылается указатель среза). Различие между длиной и ёмкостью станет понятным, когда мы рассмотрим несколько следующих примеров.

При использовании срезов s обратите внимание на изменения в структуре данных среза и их связь с базовым массивом.

```
s = s[2:4]
```
https://go.dev/blog/slices-intro/slice-2.png

При нарезке данные не копируются. Создаётся новое значение среза, которое указывает на исходный массив. Это делает операции со срезами такими же эффективными, как и манипуляции с индексами массива. Таким образом, изменение элементов (а не самого среза) при повторной нарезке приводит к изменению элементов исходного среза.

```go
d := []byte{'r', 'o', 'a', 'd'}
e := d[2:]
// e == []byte{'a', 'd'}
e[1] = 'm'
// e == []byte{'a', 'm'}
// d == []byte{'r', 'o', 'a', 'm'}
```

Ранее мы обрезали s до длины, меньшей, чем его вместимость. Мы можем увеличить s до его вместимости, снова обрезав его:

```
s = s[:cap(s)]
```
https://go.dev/blog/slices-intro/slice-3.png

Размер среза не может превышать его вместимость. Попытка сделать это приведёт к ошибке во время выполнения, как и при индексации за пределами среза или массива. Аналогичным образом, срезы нельзя уменьшать до нуля, чтобы получить доступ к более ранним элементам массива.

## Выращивание срезов (функции copy и append)

Чтобы увеличить ёмкость среза, нужно создать новый срез большего размера и скопировать в него содержимое исходного среза. Именно так работают динамические массивы в других языках программирования. В следующем примере ёмкость s увеличивается вдвое за счёт создания нового среза t, копирования содержимого s в t и последующего присвоения значения среза t переменной s:

```go
t := make([]byte, len(s), (cap(s)+1)*2) // +1 in case cap(s) == 0
for i := range s {
        t[i] = s[i]
}
s = t
```

Циклическая часть этой распространённой операции упрощается благодаря встроенной функции copy. Как следует из названия, функция copy копирует данные из исходного среза в целевой срез. Она возвращает количество скопированных элементов.

```
func copy(dst, src []T) int
```

Функция copy поддерживает копирование между срезами разной длины (она копирует только до меньшего количества элементов). Кроме того, copy может работать с исходными и целевыми срезами, которые используют один и тот же базовый массив, корректно обрабатывая перекрывающиеся срезы.

Используя copy, мы можем упростить приведённый выше фрагмент кода:

```go
t := make([]byte, len(s), (cap(s)+1)*2)
copy(t, s)
s = t
```

Распространённой операцией является добавление данных в конец среза. Эта функция добавляет байтовые элементы в срез байтов, при необходимости увеличивая срез, и возвращает обновлённое значение среза.

```go
func AppendByte(slice []byte, data ...byte) []byte {
    m := len(slice)
    n := m + len(data)
    if n > cap(slice) { // if necessary, reallocate
        // allocate double what's needed, for future growth.
        newSlice := make([]byte, (n+1)*2)
        copy(newSlice, slice)
        slice = newSlice
    }
    slice = slice[0:n]
    copy(slice[m:n], data)
    return slice
}
```

Можно использовать AppendByte следующим образом:

```go
p := []byte{2, 3, 5}
p = AppendByte(p, 7, 11, 13)
// p == []byte{2, 3, 5, 7, 11, 13}
```

Такие функции, как AppendByte, полезны, потому что они позволяют полностью контролировать процесс увеличения фрагмента. В зависимости от особенностей программы может потребоваться выделять память меньшими или большими блоками или установить максимальный размер при перераспределении.

Но большинству программ не нужен полный контроль, поэтому в Go есть встроенная функция append, которая подходит для большинства задач. Её сигнатура выглядит так:

```
func append(s []T, x ...T) []T
```

Функция append добавляет элементы x в конец среза s. Если требуется большая ёмкость, срез расширяется.

```go
a := make([]int, 1)
// a == []int{0}
a = append(a, 1, 2, 3)
// a == []int{0, 1, 2, 3}
```

Чтобы добавить один фрагмент к другому, используйте ... для преобразования второго аргумента в список аргументов.

```go
a := []string{"John", "Paul"}
b := []string{"George", "Ringo", "Pete"}
a = append(a, b...) // equivalent to "append(a, b[0], b[1], b[2])"
// a == []string{"John", "Paul", "George", "Ringo", "Pete"}
```

Поскольку нулевое значение среза (nil) действует как срез нулевой длины, вы можете объявить переменную среза, а затем добавлять в неё данные в цикле:

```go
// Filter returns a new slice holding only
// the elements of s that satisfy fn()
func Filter(s []int, fn func(int) bool) []int {
    var p []int // == nil
    for _, v := range s {
        if fn(v) {
            p = append(p, v)
        }
    }
    return p
}
```

## Возможная ловушка

Как упоминалось ранее, при повторном нарезке фрагмента не создаётся копия базового массива. Полный массив будет храниться в памяти до тех пор, пока на него не перестанут ссылаться. Иногда это может приводить к тому, что программа будет хранить все данные в памяти, хотя нужен лишь небольшой их фрагмент.

Например, эта функция FindDigits загружает файл в память и ищет в нём первую группу последовательных цифр, возвращая их в виде нового среза.

```go
var digitRegexp = regexp.MustCompile("[0-9]+")

func FindDigits(filename string) []byte {
    b, _ := ioutil.ReadFile(filename)
    return digitRegexp.Find(b)
}
```

Этот код работает так, как заявлено, но возвращаемый []byte указывает на массив, содержащий весь файл. Поскольку срез ссылается на исходный массив, пока срез существует, сборщик мусора не может освободить массив; несколько полезных байтов файла сохраняют всё его содержимое в памяти.

Чтобы решить эту проблему, можно скопировать нужные данные в новый срез перед возвратом:

```go
func CopyDigits(filename string) []byte {
    b, _ := ioutil.ReadFile(filename)
    b = digitRegexp.Find(b)
    c := make([]byte, len(b))
    copy(c, b)
    return c
}
```

Более лаконичную версию этой функции можно создать с помощью append. Это задание предлагается выполнить читателю самостоятельно.

```
