# Строки

В Go строки являются фундаментальным типом данных. Они неизменяемы, то есть после создания их нельзя изменить. Строки состоят из последовательности байтов и кодируются в UTF-8. Это означает, что каждый символ в строке представлен одним или несколькими байтами. Например, символ «é» представлен двумя байтами: 0xC3 и 0xA9. Спецификация языка Go определяет строку как последовательность байтов, а не обязательно символов. Это означает, что строка может содержать любую последовательность байтов, включая нулевые байты, и пользователь сам определяет, как следует интерпретировать эти байты.

## Создание строк

Чтобы создать строку, можно использовать двойные кавычки или обратные кавычки. Двойные кавычки используются для создания строкового литерала, а обратные кавычки — для создания необработанного строкового литерала. Строковый литерал — это последовательность символов, заключённая в двойные кавычки или обратные кавычки. Необработанный строковый литерал — это строковый литерал, который интерпретируется буквально, без каких-либо управляющих последовательностей.

```
s1 := "Hello, World!"

s2 := `Hello, World!`

fmt.Println(s1 == s2) // true
```

### Как создавать многострочные строки

Чтобы создать многострочную строку, можно использовать обратные кавычки. Можно также использовать оператор + для объединения нескольких строк, но это не рекомендуется, так как такой способ менее эффективен.

```
query := `SELECT * FROM users
WHERE id = 1 AND name = "John"`
```

## Манипулирование строками 

### Как узнать длину строки

Чтобы узнать длину строки, можно использовать функцию len . Это возможно, потому что строки в Go состоят из последовательности байтов. Функция len возвращает количество байтов в строке.

```
s := "Hello, World!"

fmt.Println(len(s)) // 13
```

### Как удалить пробелы 

Чтобы удалить пробелы из строки, можно использовать функцию strings.TrimSpace . Эта функция принимает строку в качестве аргумента и возвращает строку без начальных и конечных пробелов.

```
s := " Hello, World! "

fmt.Println(len(s)) // 15

s1 := strings.TrimSpace(s)

fmt.Println(s1) // Hello, World!
fmt.Println(len(s1)) // 13
```

Чтобы удалить пробелы в начале строки, можно использовать функцию strings.TrimLeft. Эта функция принимает два аргумента: строку, которую нужно обрезать, и набор символов, которые нужно удалить. Она возвращает строку, из которой удалены все начальные символы из набора.

Это также работает для правой части строки при использовании функции strings.TrimRight.

```
s := " Hello, World! "

fmt.Println(len(s)) // 15
s1 := strings.TrimLeft(s, " ")

fmt.Println(s1) // Hello, World!
fmt.Println(len(s1)) // 14

s2 := strings.TrimRight(s, " ")

fmt.Println(s2) //  Hello, World!
fmt.Println(len(s2)) // 14
```

### Как объединить строки 

Чтобы объединить две строки, можно использовать оператор +. Оператор + можно использовать для объединения любого количества строк.

```
s1 := "Hello, "
s2 := "World!"

s3 := s1 + s2

fmt.Println(s3) // Hello, World!
```

Мы также можем использовать fmt.Sprintf для объединения строк. fmt.Sprintf — это функция, которая возвращает строку, представляющую собой объединение строк, переданных в качестве аргументов. похожа на оператор +, но она более гибкая, поскольку с её помощью можно объединять любое количество строк.

```
s1 := "Hello, "
s2 := "World!"

s3 := fmt.Sprintf("%s%s", s1, s2)

fmt.Println(s3) // Hello, World!
```

### Объединение строк с strings.Builder

Тип strings.Builder — это структура, которая позволяет эффективно создавать строку путём записи в неё данных. Она похожа на тип bytes.Buffer, который используется для создания байтового среза. Тип strings.Builder полезен, когда нужно объединить большое количество строк, поскольку он позволяет избежать создания новой строки при каждом объединении двух строк, что повышает производительность.

```
s1 := "Hello, "
s2 := "World!"

var b strings.Builder

b.WriteString(s1)
b.WriteString(s2)

s3 := b.String()

fmt.Println(s3) // Hello, World!
```

### Как разделить строки 

Чтобы разбить строку на массив строк, можно использовать функцию strings.Split . Эта функция принимает два аргумента: строку, которую нужно разбить, и разделитель, по которому нужно разбить строку. Она возвращает массив строк, полученных в результате разбиения строки по разделителю.

```
s := "Hello, World!"

s1 := strings.Split(s, ", ")

fmt.Println(s1) // Hello World!
```

### Как объединить строки 

Чтобы объединить несколько строк в одну, можно использовать функцию strings.Join . Эта функция принимает два аргумента: список строк, которые нужно объединить, и разделитель для объединения. Она возвращает строку, которая является результатом объединения списка строк с помощью разделителя.

```
s := []string{"Hello", "World!"}

s1 := strings.Join(s, ", ")

fmt.Println(s1) // Hello, World!
```

### Как разделить строки по индексу 

Можно разделить строку по индексу с помощью функции strings.SplitN() Эта функция принимает в качестве аргументов строку, разделитель и количество частей, на которые нужно разделить строку, и возвращает срез строк. В следующем примере показано, как разделить строку по индексу с помощью функции strings.SplitN()

```
package main

import (
  "fmt"
  "strings"
)

func main() {
  str := "Do or do not, there is no try."
  strSlice := strings.SplitN(str, " ", 2)
  fmt.Println(strSlice) // Do or do not, there is no try.
  fmt.Println(len(strSlice)) // 2
}
```

### Как преобразовать строки в числа 

Чтобы преобразовать строку в число, можно использовать функцию strconv.Atoi -  или strconv.ParseInt -  в зависимости от типа числа, в которое вы хотите преобразовать строку.

```
s := "123"

i, err := strconv.Atoi(s)

if err != nil {
    fmt.Println(err)
}

fmt.Println(i) // 123
```

```
s := "123"

i, err := strconv.ParseInt(s, 10, 64)

if err != nil {
    fmt.Println(err)
}

fmt.Printf("%T\n", i) // int64
```

### Как проверить, содержит ли строка подстроку

Чтобы проверить, содержит ли строка подстроку, можно использовать функцию strings.Contains . Эта функция принимает два аргумента: проверяемую строку и подстроку для проверки. Она возвращает логическое значение, указывающее, содержит ли строка подстроку.

```
s := "Hello, World!"

fmt.Println(strings.Contains(s, "Hello")) // true
fmt.Println(strings.Contains(s, "World")) // true
fmt.Println(strings.Contains(s, "Foo")) // false
```

### Как заменить подстроку в строке 

Чтобы заменить подстроку в строке, можно использовать функцию strings.Replace . Эта функция принимает четыре аргумента: строку, которую нужно заменить, подстроку, которую нужно заменить, строку для замены и количество замен. Она возвращает строку с заменённой подстрокой.

```
s := "Golang is awesome!"

s1 := strings.Replace(s, "awesome", "great", 1)

fmt.Println(s1) // Golang is great!
```

Вы также можете использовать функцию strings.ReplaceAll для замены всех вхождений подстроки в строке.

```
s := "Golang is awesome and awesome!"

s1 := strings.ReplaceAll(s, "awesome", "great")

fmt.Println(s1) // Golang is great and great!
```

### Как перевернуть строку 

Чтобы перевернуть строку, нужно преобразовать её в срез рун. Затем можно использовать цикл for - для перебора среза рун и добавления каждой руны в новый срез рун. Наконец, можно преобразовать срез рун в строку.

```
s := "Hello, World!"

r := []rune(s)

for i, j := 0, len(r)-1; i < j; i, j = i+1, j-1 {
    r[i], r[j] = r[j], r[i]
}

s1 := string(r)

fmt.Println(s1) // !dlroW ,olleH
```

Проблема этого подхода в том, что он требует преобразования строки в массив рун, а затем обратно в строку. Это не очень эффективно. Более правильный подход — использовать тип strings.Builder . Вы можете использовать тип strings.Builder для создания строки, добавляя к ней символы. Затем вы можете использовать метод strings.Builder.String для получения строки.

```
s := "Hello, World!"

var b strings.Builder

for i := len(s) - 1; i >= 0; i-- {
    b.WriteByte(s[i])
}

s1 := b.String()

fmt.Println(s1) // !dlroW ,olleH
```

При работе с кодировками вы можете использовать пакет unicode/utf8 для реверсирования строки. Пакет unicode/utf8 предоставляет функции для декодирования и кодирования строк в кодировке UTF-8. Вы можете использовать функцию utf8.DecodeRuneInString для декодирования одной руны в кодировке UTF-8 из строки. Затем вы можете использовать функцию utf8.EncodeRune для кодирования одной руны в кодировке UTF-8 в строку.

```
s := "The quick brown 狐 jumped over the lazy 犬"

var b strings.Builder

for len(s) > 0 {
    r, size := utf8.DecodeRuneInString(s)
    b.WriteRune(r)
    s = s[size:]
}

s1 := b.String()

fmt.Println(s1) // 犬 yzal eht revo depmuj 狐 nworb kciuq ehT
```

### Как преобразовать строку в верхний или нижний регистр

Чтобы преобразовать строку в верхний регистр, можно использовать функцию strings.ToUpper . Эта функция возвращает строку, в которой все символы написаны заглавными буквами.

```
s := "Hello, World!"

s1 := strings.ToUpper(s)

fmt.Println(s1) // HELLO, WORLD!
```

Чтобы преобразовать строку в нижний регистр, можно использовать функцию strings.ToLower . Эта функция возвращает строку, в которой все символы написаны строчными буквами.

```
s := "Hello, World!"

s1 := strings.ToLower(s)

fmt.Println(s1) // hello, world!
```

### Как преобразовать строку в верхний регистр

Чтобы преобразовать строку в верхний регистр, можно использовать функцию cases.Title из пакета golang.org/x/text/cases - .

Эта функция принимает в качестве аргументов языковой тег и строку и возвращает строку, в которой первая буква каждого слова написана заглавными буквами.

Установите golang.org/x/text/cases пакет

Чтобы установить пакет golang.org/x/text/cases, вы можете использовать команду go get .

```
go get golang.org/x/text/cases
go get golang.org/x/text/language
```

```
import "golang.org/x/text/cases"
import "golang.org/x/text/language"
```

```
s := "hello, world!"

s1 := cases.Title(language.English).String(s)

fmt.Println(s1) // Hello, World!
```

strings.Title В Go 1.18 этот метод был признан устаревшим и заменён функцией cases.Title . Хотя strings.Title по-прежнему работает, рекомендуется использовать функцию cases.Title или функцию strings.ToTitle .


```
str := "ǳ"

fmt.Println(strings.ToTitle(str)) // ǲ
fmt.Println(strings.ToUpper(str)) // ǲ
```

### Как проверить, начинается ли строка с подстроки или заканчивается ею

Чтобы проверить, начинается ли строка с подстроки, можно использовать функцию strings.HasPrefix . Возвращает логическое значение, указывающее, начинается ли строка с подстроки.

```
s := "Hello, World!"

fmt.Println(strings.HasPrefix(s, "Hello")) // true
fmt.Println(strings.HasPrefix(s, "World")) // false
```

Чтобы проверить, заканчивается ли строка подстрокой в Go, можно использовать функцию strings.HasSuffix . Возвращает логическое значение, указывающее, заканчивается ли строка подстрокой.

```
s := "Hello, World!"

fmt.Println(strings.HasSuffix(s, "Hello")) // false
fmt.Println(strings.HasSuffix(s, "World!")) // true
```

### Как найти индекс подстроки в строке 

Чтобы найти индекс подстроки в строке, можно использовать функцию strings.Index . Возвращает индекс первого вхождения подстроки в строку.

```
s := "Hello, World!"

fmt.Println(strings.Index(s, "Hello")) // 0
fmt.Println(strings.Index(s, "World!")) // 7

fmt.Println(strings.Index(s, "Foo")) // -1
```

Если подстрока не найдена в строке, функция возвращает -1.

Чтобы найти индекс последнего вхождения подстроки в строку, можно использовать функцию strings.LastIndex .

```
// I know this doesn't make sense, but it's just an example.
s := "Data is the new oil and oil is the new data"

fmt.Println(strings.LastIndex(s, "data")) // 39
fmt.Println(strings.LastIndex(s, "oil")) // 24
```

### Как подсчитать количество вхождений подстроки в строку 

Чтобы подсчитать количество вхождений подстроки в строку, можно использовать функцию strings.Count. Возвращает количество вхождений подстроки в строку.

```
s := "data is the new oil and oil is the new data"

fmt.Println(strings.Count(s, "data")) // 2
fmt.Println(strings.Count(s, "oil")) // 2
```

### Как преобразовать логическое значение в строку 

Чтобы преобразовать логическое значение в строку, можно использовать функцию strconv.FormatBool. Возвращает строковое представление логического значения.

```
b := true

s := strconv.FormatBool(b)

fmt.Println(s) // true
fmt.Printf("%T", s) // string
```

### Как сравнивать строки 

Для сравнения строк можно использовать оператор == . Возвращает логическое значение, указывающее, равны ли строки.

```
s1 := "Hello, World!"
s2 := "Hello, World!"

fmt.Println(s1 == s2) // true
```

### Как преобразовать строку в массив байтов 

Чтобы преобразовать строку в байтовый срез, можно использовать преобразование типа []byte . Вернёт байтовый срез, представляющий строку.

```
s := "Hello, World!"

b := []byte(s)

fmt.Println(b) // 72 101 108 108 111 44 32 87 111 114 108 100 33
```

## Задачи для самостоятельной работы

### 1. Проверить, являются ли две строки анаграммами

**Задание.** Даны две строки `s` и `t`. Нужно определить, содержат ли они одни и те же символы в тех же количествах (т. е. являются ли анаграммами).

**Вход:** две строки `s` и `t`.
**Выход:** `YES`, если являются анаграммами, иначе `NO`.

**Алгоритм (естественным языком):**

1. Если длины строк `s` и `t` различаются — сразу вернуть `NO` (нельзя быть анаграммами).
2. Выбрать способ учёта символов:

   * Если алфавит ограничен (например, только строчные латинские буквы), подготовить массив счётчиков длиной равной размеру алфавита (например, 26) и инициализировать нулями.
   * Если алфавит произвольный (включая Unicode), подготовить ассоциативный массив / словарь (map), где ключ — символ, значение — счётчик.
3. Пройти по всем символам строки `s`. Для каждого символа увеличить соответствующий счётчик на 1.
4. Пройти по всем символам строки `t`. Для каждого символа уменьшить соответствующий счётчик на 1. Если в процессе встретился символ, которого не было в `s` (в словаре нет записи) — считать счётчик как 0 и уменьшать (это приведёт к отрицательному значению).
5. После обработки обеих строк проверить все счётчики: если все равны 0 — вернуть `YES`, иначе — `NO`.
6. Опционально: можно вместо двух проходов сделать сортировку строк и сравнение — отсортировать `s` и `t` и сравнить полученные строки; это проще в реализации, но медленнее (O(n log n)).

**Граничные случаи:** пустые строки считаются анаграммами друг друга. Учесть различие регистра (если нужно — привести всё к нижнему регистру).

**Тестовый вход / выход:**
Вход:

```
s = "listen"
t = "silent"
```

Выход:

```
YES
```

---

### 2. Наибольший общий префикс массива строк

**Задание.** Дан массив строк `arr`. Найти самый длинный префикс (начало строки), который является общим для всех строк массива.

**Вход:** массив строк `arr` длины `n` (может быть `n = 0`).
**Выход:** строка — наибольший общий префикс (если общего префикса нет — пустая строка).

**Алгоритм (естественным языком):**

1. Если массив пустой (`n = 0`) — вернуть пустую строку.
2. Если в массиве есть хотя бы одна строка пустая — вернуть пустую строку (общий префикс не может быть длиннее пустой строки).
3. Выбрать опорную строку: например, первую строку `first = arr[0]`.
4. Инициализировать `prefix_length = длина(first)`. Мы будем сжимать это значение.
5. Для каждой строки `s` из массива (начиная со второй):
   a. Пока `prefix_length > 0` и префикс `first[0:prefix_length]` не совпадает с началом `s` (т.е. первые `prefix_length` символов `s`), уменьшать `prefix_length` на 1.
   b. Если `prefix_length == 0`, можно сразу вернуть пустую строку.
6. После прохода по всем строкам вернуть подстроку `first[0:prefix_length]`.
7. (Альтернатива с бинпоиском по длине) Можно искать максимально возможную длину префикса бинарным поиском: проверять для средней длины L, совпадают ли первые L символов у всех строк (за один проход), и сузить интервал; это эффективно при очень длинных строках с дорогой проверкой.

**Граничные случаи:** строки разной длины, массив с одной строкой (возвращаем саму строку).

**Тестовый вход / выход:**
Вход:

```
arr = ["flower", "flow", "flight"]
```

Выход:

```
"fl"
```

---

### 3. Поиск подстроки — алгоритм Кнута–Морриса–Пратта (KMP)

**Задание.** Даны текст `txt` и шаблон `pat`. Нужно найти индекс первого вхождения `pat` в `txt` (0-based). Если вхождения нет — вернуть `-1`.

**Вход:** строки `txt` и `pat`.
**Выход:** целое число — индекс первого вхождения шаблона в тексте либо `-1`.

**Алгоритм (естественным языком):**

1. Если `pat` пустая строка — вернуть `0` (по соглашению, пустой шаблон вхож в текст с позиции 0).
2. Если длина `pat` > длины `txt` — вернуть `-1`.
3. Построить префикс-функцию (часто называемую `pi`) для строки `pat`. Как построить `pi`:
   a. Создать массив `pi` длины `m` (m = |pat|), заполнить нулями.
   b. Для `i` от 1 до m-1 поддерживать `j = pi[i-1]`. Пока `j > 0` и `pat[i] != pat[j]`, делать `j = pi[j-1]`. Если `pat[i] == pat[j]`, увеличить `j` на 1. Затем `pi[i] = j`.
   (Иными словами: для каждого префикса `pat[0..i]` находим длину максимального собственного префикса, который равен суффиксу.)
4. Выполнить проход по тексту `txt`, используя `pi`:
   a. Инициализировать `j = 0`.
   b. Для каждого индекса `i` от 0 до n-1 (n = |txt|):

   * Пока `j > 0` и `txt[i] != pat[j]`, присваивать `j = pi[j-1]`.
   * Если `txt[i] == pat[j]`, увеличить `j` на 1.
   * Если `j == m` (достигли длины шаблона) — нашли вхождение: вернуть `i - m + 1` (позиция начала).
5. Если прошли весь текст и `j != m` — вернуть `-1`.

**Почему это работает:** `pi` помогает не возвращаться в тексте назад, а двигать шаблон «вперёд» эффективно.

**Сложность:** построение `pi` — O(m), поиск — O(n). Всего O(n + m) по времени, O(m) памяти.

**Тестовый вход / выход:**
Вход:

```
txt = "abxabcabcaby"
pat = "abcaby"
```

Выход:

```
6
```

---

### 4. Наибольшая палиндромная подстрока (Manacher / центр-расширение)

**Задание.** Дана строка `s`. Найти любую её самую длинную подстроку, которая читается одинаково слева направо и справа налево.

**Вход:** строка `s`.
**Выход:** самая длинная палиндромная подстрока (если таких несколько одинаковой длины — можно вернуть любую).

**Алгоритм (естественным языком, два варианта):**

**Вариант A — Manacher (линейное время, рекомендовано для больших строк):**

1. Преобразовать строку, чтобы унифицировать нечётные и чётные палиндромы: вставить разделитель (например `#`) между символами и в начале/конце. Например, `s = "abba"` → `t = "^#a#b#b#a#$"` (символы начала/конца упрощают проверки).
2. Создать массив `P` длины `|t|`, где `P[i]` — радиус палиндрома в позиции `i` в `t`.
3. Поддерживать центр `C` и правую границу `R` текущего самого правого палиндрома.
4. Для каждого `i` выполнять:
   a. Найти зеркальную позицию `mirror = 2*C - i`.
   b. Инициализировать `P[i] = min(R - i, P[mirror])` если `i < R`, иначе `P[i] = 0`.
   c. Попытаться расширить палиндром вокруг `i` увеличивая `P[i]` пока символы по сторонам равны.
   d. Если `i + P[i] > R`, обновить `C = i`, `R = i + P[i]`.
5. Найти индекс `i` с максимальным `P[i]`. Перевести этот индекс/радиус обратно в позицию в исходной строке `s` и вернуть соответствующую подстроку.
6. Сложность O(n).

**Вариант B — расширение в центре (простая реализация, O(n^2) в худшем случае):**

1. Для каждого индекса `i` рассматривать палиндромы двух типов:

   * нечётный палиндром с центром в `i`: начать с левых = i, правых = i и расширять наружу пока символы равны;
   * чётный палиндром с центром между `i` и `i+1`: начать с левых = i, правых = i+1.
2. При каждом расширении отслеживать максимальную длину и позицию.
3. В конце вернуть подстроку по максимальным границам.
4. Простая и ясная, но для строк длины 10^5 худшая сложность O(n^2) делает её непригодной; для n ≤ 10^4 часто достаточно.

**Тестовый вход / выход (пример):**
Вход:

```
s = "babad"
```

Возможный выход:

```
"bab"   (или "aba")
```

---

### 5. Расстояние Левенштейна (редакционное расстояние)

**Задание.** Даны строки `s` и `t`. Нужно вычислить минимальное количество операций (вставка символа, удаление символа, замена символа), необходимых, чтобы превратить `s` в `t`.

**Вход:** строки `s` и `t`.
**Выход:** целое число — минимальное число операций (расстояние Левенштейна).

**Алгоритм (естественным языком, классический DP):**

1. Обозначим `n = длина(s)`, `m = длина(t)`.
2. Создать (в уме/логике) таблицу `dp` размером `(n+1) x (m+1)`, где `dp[i][j]` — минимальное число операций для превращения первых `i` символов `s` в первые `j` символов `t`.
3. Инициализация:

   * `dp[0][0] = 0` (пустая → пустая).
   * Для `i` от 1 до n: `dp[i][0] = i` (удалить i символов).
   * Для `j` от 1 до m: `dp[0][j] = j` (вставить j символов).
4. Переход (заполнение таблицы):
   Для каждого `i` от 1 до n и каждого `j` от 1 до m:

   * Если `s[i-1] == t[j-1]` (последние символы равны), тогда `cost = 0`, иначе `cost = 1`.
   * Рассчитать три варианта:
     a. удаление: `dp[i-1][j] + 1` (удалить `s[i-1]`),
     b. вставка: `dp[i][j-1] + 1` (вставить `t[j-1]` в `s`),
     c. замена (или совпадение): `dp[i-1][j-1] + cost`.
   * `dp[i][j]` — минимум из этих трёх.
5. Ответ — `dp[n][m]`.
6. Оптимизация по памяти: хранить не всю матрицу, а только две строки `prev` и `cur` (или даже одну при аккуратных переходах), потому что `dp[i][*]` зависит только от `dp[i-1][*]` и `dp[i][j-1]`.
7. Сложность: O(n·m) по времени, O(min(n,m)) по памяти с оптимизацией.

**Граничные случаи:** одна строка пустая — расстояние равно длине другой строки.

**Тестовый вход / выход:**
Вход:

```
s = "kitten"
t = "sitting"
```

Выход:

```
3
```

(замены: k→s, вставка i, вставка g — общее 3 операции)

---
